---
layout: default
title: Introduction to the Stack-Of-Tasks SDK
group: navigation
---

    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async
	    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

<h1 id="sot_introduction" class="page-header">{{ page.title }}</h1>

<h2>Writing a controller</h2>
The goal of the Stack-of-Tasks (SoT) is to provide a SDK in order to:
<ul>
  <li id="write_control_pb"> Write control problem for complex robots such as humanoid robots</li>
  <li id="test_control_pb"> Test them quickly using geometric settings (rviz, gepetto-viewer), dynamic simulators (ODE,Bullet), system simulator (Gazebo)</li>
  <li id="deploy_control_pb"> Deploy them in real robots (TALOS, HRP-2)</li>
</ul>
Depending on your target you might not be interested in using the full set of software we are providing.
But the main goal of this SDK is to consider a robot model $robot\_model$, its current state $\mathbf{x}$
and computes a control vector $\mathbf{u}$
to make the robot performs actions.
<br>
The central concept of our control architecture is the notion of task.

<h3> Formulating tasks </h3>

<h4> Definition</h4>
Task ($\mathbf{e}$) are using features ($\mathbf{s}$). Features might be end-effector posision (hands, feet), the robot center-of-mass, or
the center-of-gravity of an object projected in the image.
We assume that a function relates the current state of the robot typically the configuration, speed, acceleration
to a feature. For instance, we may want to consider the Center-Of-Mass of a robot specified by a model $robot\_model$
and a configuration vector $\mathbf{q}$:

$$ \mathbf{f}_{CoM}: (robot\_model, \mathbf{q}) \rightarrow \mathbf{c}$$

We further assume that this function is at least differentiable once.
The current software library we are using to computate such features, theirs derivatives
 is <a href="http://stack-of-tasks.github.io/pinocchio/">Pinocchio</a><sup>
  <a href="#fn1" id="ref1">1</a></sup>. Pinocchio include dynamical quantities such as angular momentum and its derivatives.

A task is then defined by the regulation between the feature depending on the current state $\mathbf{s}(\mathbf{q})$
of the robot and a desired feature $\mathbf{s}^*$:
$$ \mathbf{e} = \mathbf{s}(\mathbf{q})- \mathbf{s}^* $$

<h4> Imposing the task dynamic </h4>
You can impose for instance that the task dynamic is an exponential decay:
$$ \mathbf{\dot{e}} = - \lambda \mathbf{e}$$
But we also have:
$$\mathbf{\dot{e}} = \mathbf{\dot{s}}(\mathbf{q}) - \mathbf{\dot{s}}^*$$
If the desired feature does not move we have $\mathbf{\dot{s}}^*=0$, in addition we can remark that
$\mathbf{\dot{s}}(\mathbf{q})=\frac{\delta s}{\delta q}\mathbf{\dot{q}} = \mathbf{J}(\mathbf{q})\mathbf{\dot{q}}$


<h3> Formulating instantaneous control as optimization problem</h3>

The task function is allowing a very versatile formulation including
<ul>
  <li> Hierarchy of tasks </li>
  <li> Weighted problems </li>
</ul>

<sup id="fn1">1. [Historically we have used <a href="https://github.com/jrl-umi3218/jrl-dynamics">jrl-dynamics</a> coupled with the toolbox 
<a href="http://www.inrialpes.fr/bipop/software/humans/">HuMAnS</a> for efficient computation. Unfortunately HuMAnS is using Mapple
so we tried to use a template based approach called 
<a href="https://github.com/laas/metapod">Metapod</a> co-developed with Aldebaran Robotics now Softbank Robotics. Reading the book Rigid Body Dynamics from Featherstone
shows that generated code might lead to a lot of code loaded in the memory. This happens to be less efficient than compact code with simple loops
as implemented in Pinocchio.
]<a href="#ref1" title="Jump back to footnote 1 in the text.">â†©</a></sup>
<div style="padding: 10em"></div>
